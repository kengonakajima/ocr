# OCR用のVLMを作る


文字の位置までピクセル単位で正確に検出するOCR対応のVLMを作るには、大きくは「文字検出（Detection）」「文字認識（Recognition）」「位置回帰（Localization）」という３つのタスクを一つのモデル（またはパイプライン）でマルチタスク学習する設計が必要です。コードではなく概念レベルで、主に以下のステップを踏みます。

---

### 1. データ準備・アノテーション

* **文字単位のバウンディングボックスアノテーション**
  文字列全体ではなく、各文字（または文字クラス）ごとにバウンディングボックスを矩形で囲み、座標をピクセル単位で記録します。
* **合成データ＋実データの組み合わせ**
  合成文字画像（例：SynthText など）を大量に生成して「あらゆる背景・フォント・歪み」への耐性を付けつつ、実際の撮影画像を手動アノテーションしてドメインギャップを埋めます。

---

### 2. モデルアーキテクチャ設計

* **バックボーン（特徴抽出）**
  CNN や ViT（Vision Transformer）などで画像特徴を空間的に抽出。
* **検出ヘッド（Detection Head）**
  DETR や Mask R-CNN のように、特徴マップから「文字があるかどうか」を分類し、かつバウンディングボックス（xmin, ymin, xmax, ymax）を回帰する部分を持たせる。
* **認識ヘッド（Recognition Head）**
  RoIプーリングやアテンション機構で切り出した文字領域を、CTC やシーケンス・トゥー・シーケンスの文字認識器で “何という文字か” を判定。
* **マルチタスク構成**
  「検出 × 認識」を統合し、共有バックボーン＋二つのヘッドで同時に学習できるように設計します。

---

### 3. 損失関数の定義

* **検出ロス**

  * ボックス回帰：L1ロス＋GIoUロスなど
  * クラス分類：クロスエントロピー
* **認識ロス**

  * CTCロス、またはシーケンスCEロス
* **重み付け**
  Detection Loss と Recognition Loss の重要度を経験的に調整し、どちらかに偏りすぎないようにバランスを取ります。

---

### 4. 学習戦略

* **段階的ファインチューニング**
  ①合成データで大まかな文字検出・認識能力を獲得→②実データで微調整
* **データ拡張**
  文字の回転・スケール・透過ノイズなど、多様な変形を与えロバスト性を向上。
* **学習率スケジュール**
  ウォームアップやコサインアニーリングなどを使って過学習を防止。

---

### 5. 推論時の後処理

* **NMS（Non-Maximum Suppression）**
  重複するバウンディングボックスを整理して、最終的に画素位置がクリアな１文字１ボックスに絞り込む。
* **文字の整列・読み順付け**
  検出された文字ボックスを行・列方向にソートして、文脈上正しい読み順の文字列を再構築。
* **サブピクセル補正**
  場合によってはボックス座標をさらに細かく補正（例：回帰ネットワークのサブピクセル推定）し、ピクセル未満のずれも最小化。

---

### 6. 評価・チューニング

* **検出精度評価**
  IoU閾値ごとのAP（Average Precision）やRecall/Precisionを計測。
* **認識精度評価**
  文字単位の正答率、WER（Word Error Rate）など。
* **エラー診断**
  誤検出・見落とし・誤認識の各ケースを解析し、データ拡張やネットワーク構造の微調整にフィードバック。

---

以上を繰り返し改善することで、文字のピクセル単位位置まで正確に検出・認識できるVLM型OCRシステムを構築できます。





## macbookでも作れるVLMにするための追加制約


32 GBのメモリ上で動くように設計を軽量化するには、大きく次のような「制約／前提条件」を課してみるとよいでしょう。以下、アイデアをカテゴリ別に列挙します。

---

## 1. 入力データの制約

* **固定解像度**

  * 入力画像を最大 640×640 や 800×800 などにリサイズし、それ以上大きいものは受付けない
* **グレースケール限定**

  * カラー画像はグレースケールに変換してチャンネル数を１に
* **背景・コントラストの定義**

  * 白地黒文字のみ対応（雑多な背景／カラーテクスチャは非対応）
* **撮影条件の統一**

  * 書類スキャン／スマホ水平撮影のみ受け付け、傾きや遠近歪みは許容しない

## 2. 対応文字種・フォントの制限

* **フォント固定**

  * Arial／Times New Roman など特定フォントのみ対応
* **文字種限定**

  * 英数字＋記号のみ（日本語や多言語は非対応）
* **文字サイズレンジ指定**

  * 例えば 12 pt～36 pt の文字だけ検出

## 3. 空間的・幾何学的制約

* **回転非対応／水平文字のみ**

  * 文字列は完全に水平に並んでいる想定
* **パース（遠近）非対応**

  * カメラの平行投影に近い画像のみ
* **文字間隔・行間の固定**

  * レイアウトは行ごとに同じ間隔、可変レイアウトは非対応

## 4. モデルアーキテクチャの軽量化

* **小型バックボーン採用**

  * MobileNetV3‐Lite、EfficientNet‐Lite、Tiny‐ViT など
* **マルチスケール機能の簡素化**

  * FPN 等の重い機構を省略、単一スケールで検出
* **RoI pooling の簡易化**

  * レイヤ数を削減し、プーリングサイズも固定（例：8×8 だけ）

## 5. モデル圧縮・量子化

* **量子化**

  * 32 bit → 8 bit 整数量子化でパラメータサイズを 1/4 に
* **プルーニング**

  * 重要度の低いチャンネルや層を切り落としてネットワークを細くする
* **知識蒸留**

  * 大きい「教師モデル」から小さい「生徒モデル」へ知識を転移

## 6. パイプライン上の工夫

* **スライディングウィンドウ限定**

  * 一度に処理するパッチを小さくし、メモリ使用量を固定化
* **バッチサイズ 1 固定**

  * 学習／推論ともにバッチは常に 1 枚
* **アクティベーションチェックポイント**

  * 勾配計算時に中間活性化を必要最小限しか保持しない

---

これらの制約を組み合わせることで、モデルサイズ・推論時のアクティベーションやテンソルを減らし、32 GB RAM の範囲内で十分動作させることが可能になります。
たとえば、

1. **入力は白黒 640×640、水平英数字のみ**
2. **バックボーンは MobileNetV3-Lite、量子化済み、バッチ１**
3. **検出ヘッドは単一スケール、RoI は固定サイズプーリング**

とすれば、推定メモリ使用量が数 GB 程度に抑えられます。

---

もし、さらに具体的に「どの制約をどの程度かけるとメモリがいくら節約できるか」などを検証したい場合は、実際に小さなプロトタイプでメモリプロファイリングを行うのがおすすめです。どの制約を優先したいか、あるいは許容できる品質低下のレベルなども教えていただければ、さらに絞り込んだ提案ができます！



### フォント選定

まずフォントを固定したいです。そうした目的に最適なフォントってありますか。



文字検出・認識をぐっと楽にするために「フォントを固定」するのであれば、以下のようなポイントでフォントを選ぶとよいでしょう。

---

## 選定基準

1. **字形の差が大きい**
   似た文字（O／0、I／l、S／5 など）がなるべく混同しにくい。
2. **モノスペース（等幅）**
   文字ごとに幅が一定なら、検出時の行・列レイアウト推定が簡単に。
3. **シンプルなアウトライン**
   無駄な装飾がなく、太さやコントラストが均一。
4. **オープンライセンス／埋め込み可能**
   商用・再配布も安心して使えるもの。

---

## おすすめフォント候補

| フォント名                     | 特長                                         | カバー文字                  |
| ------------------------- | ------------------------------------------ | ---------------------- |
| **OCR-B**                 | ANSI 標準の OCR 用フォント。ほどよく丸みがあり可読性高い。         | 英数字＋記号（一部拡張版でラテン拡張対応も） |
| **OCR-A**                 | より機械読み取りに特化した角ばったデザイン。誤認識率極小。              | 英数字＋記号                 |
| **Consolas**              | Windows 標準のモノスペース。字形差が大きく、プログラミング用途にも使われる。 | Unicode ラテン＋記号         |
| **DejaVu Sans Mono**      | フリーで多言語対応の等幅フォント。英語以外の言語も必要ならこちら。          | ラテン＋ギリシャ＋キリルほか         |
| **Noto Sans Mono CJK JP** | 日本語モノスペースが必要なら。ストロークが均一で読みやすい。             | 日本語＋英数字                |

---

### 最適な選び方の例

1. **英数字のみなら**
   → 誤認識ゼロを目指すなら **OCR-B**。学術・産業用途のスタンダードです。
2. **プログラミング風テキスト（記号多め）なら**
   → **Consolas** や **DejaVu Sans Mono**。手軽に入手でき、多言語にも対応。
3. **日本語を含むドキュメントなら**
   → 一旦ラテン文字を OCR-B に固定し、日本語は別途専用モデルに任せるか、
   → 全部まとめて扱うなら **Noto Sans Mono CJK JP** のような一貫した等幅フォント。

---

これらはすべて「文字形状が固定」という制約を最大限に活かし、Detection→Recognition の両タスクを非常にシンプルにしてくれます。まずは OCR-B／OCR-A でパイロット実験し、十分な精度が得られれば他フォントへの拡張を検討すると良いでしょう。




